* TODO Аннотация

  TODO: https://habr.com/ru/company/badoo/blog/420407/

* Содержание :TOC:
- [[#аннотация][Аннотация]]
- [[#парадокс-c][Парадокс C]]
- [[#ненаивная-критика-с][(Не?)наивная критика С]]
- [[#язык-прошлого-из-прошлого][Язык прошлого из прошлого]]
- [[#семейная-история-c][Семейная история: C++]]
- [[#гадание-на-абстракциях][Гадание на абстракциях]]

* Парадокс C

  За последние десятилетия академики и практики предложили множество интереснейших языков
  программирования: чистый и красивый Standard ML, практичный OCaml, радикальный Haskell, динамичный
  Smalltalk, несравненный в метапрограммировании D и многие другие. Какие-то из них ограниченно
  используются до сих пор, другие повлияли на следующие поколения языков, популярность третьих со
  временем просто тихо сошла на нет.

  Между тем, архаичный, противоречивый, примитивный, сделанный в худших традициях своего поколения
  языков C (и его наследники) живее всех живых. Видимо, что-то Денис Ричи все-таки сделал правильно,
  что бы не говорили критики.

* (Не?)наивная критика С

  В исходной статье, критикующей C, многократно подчеркивается, что C мало того, что не является
  низкоуровневым, так еще и не позволяет упрощать работу оптимизирующих компиляторов.

  Автор цитирует следующее определение низкоуровневого языка: "Язык программирования является
  низкоуровневым, если написанные на нём программы требуют внимания к несущественному". Я не стану
  здесь спорить. Но "несущественное" сильно зависит от контекста конкретной задачи. При написании,
  например, базы данных или интерпретатора языка программирования несущественные в прикладном коде
  детали становятся очень даже существенными!

  Лично мне ближе следующее определение:"Язык программирования является настолько низкоуровневым,
  насколько он близок к языку ассемблера целевой платформы". В конце концов, языки ассемблера по
  определению - интерфейс процессора, и ниже уже только детали реализации конкретного набора
  инструкций в кремнии.

  И да, у абстрактной машины языка C много общего с низлежащей машиной: плоская лента памяти (aka
  единое адресное пространство), последовательное выполнение программ, изменяемые данные.
  Многоуровневые кеши процессора - просто техника оптимизации этой самой ленты памяти.

  Многоуровневый кеш, сложные протоколы когерентности кешей, ILP (instruction-level parallelism) со
  следущими из него переименованием регистров и предсказателем ветвлений - все это оптимизации этих
  самых плоской ленты памяти и последовательно выполняемых программ.

  Но дело в том, что в самом широком смысле актуальные архитектуры имитируют не какой-то конкретный
  язык программирования, а машину Тьюринга. Ей же соответствует и абстрактная машина языка C. Автор
  критикующей статьи Дэвид Чизнэлл - серьезный академик из Кембриджа, а в академической среде по
  ряду вполне достойных причин при разработке языков предпочитают отталкиваться от
  лямбда-исчисления.

  Доказано, что лямбда-исчисление эквивалентно машине Тьюринга по вычислительной мощности, но
  реализация его в железе не столь очевидна. С другой стороны, свойства языков, основанных на
  лямбда-исчислении, намного легче формализуются и именно поэтому академики их так любят.

  Но фокус в том, что физические машины - это именно машины Тьюринга по сути. Эквивалентность
  эквивалентностью, но именно такая модель легче всего реализуется в транзисторах. Не PDP-11, не
  какой-то конкретный язык программирования, а десятилетия архитектурных экспериментов показали, что
  именно так достигается оптимальная производительность /в общем случае/.

  Подходы типа VLIW (very long instruction word), Lisp-машин или SIMD, лежащий в основе GPU и
  векторных АЛУ в процессоре, имеют смысл в специальных задачах, но ни в коем случае не
  универсальны. Itanium не даст соврать!

* Язык прошлого из прошлого

  Надеюсь, мы выяснили, что абстрактная машина С похожа на машину реальную: возможность работать с
  памятью через указатели и арифметику указателей, близкий к железу набор типов, возможность при
  необходимости работать на уровне отдельных байтов. Полученные после прохода компилятора C листинги
  на языке ассемблера однозначно отображаются в исходный код. Все эти вещи - именно то, ради чего
  иногда все-таки приходится писать на С.

  Си придает много значения вопросам обратной совместимости, и, как и машина, эволюционирует крайне
  медленно. Изрядная часть нововведений - желание устранить разницу между тем, как работает реальная
  машина, и тем, как это видит программист на C.

  Заметьте, что практически все высокоуровневые средства построения абстракций в C устарели. Из
  актуального, наверное, тут только бессмертные функции, структуры и текстовые макроподстановки.
  Если задуматься, то даже связанные с работой функций механизмы уже показывают свой возраст:
  половину "костылей" вокруг языка можно было бы удалить, будь у разработчиков возможность
  возвращать одновременно несколько значений из функций

  Откровенно музейные экспонаты: строки, завершаемые нулем; реализация широких символов; почти вся
  стандартная библиотека. Да что там..! Из стандартной библиотеки в наши дни использовать можно
  только простейшее побайтовое копирование. И хорошо еще, что консервативность языка не позволила
  включить в стандарт всякие мимолетные модные веяния, коих накопилось бы за 30 лет, прошедших с
  момента принятия стандарта ANSI.

  Словом, ключевая причина популярности C - не успех его как языка, а близость самой базовой модели,
  на которой строятся современные компьютеры.

* Семейная история: C++

  Консервативность C - притча во языцах. Но не все низкоуровневые языки выбрали столь консервативный
  подход к развитию.

  В семейство низкоуровневых языков принято включать С++, который в известной степени сохраняет
  низкоуровневые возможности C, но проводит гораздо более либеральную политику в вопросах
  включения в стандарт новых возможностей.

  Основа языка - все та же прямая работа с памятью, но поверх добавлено несколько поколений средств
  абстрагирования: классы, шаблоны классов и функций, богатая библиотека шаблонов и, наконец,
  современные средства метапрограммирования. Требование сохранения обратной совместимости означало,
  что новые возможности накладывались поверх старых, что получалось... Не совсем аккуратно.

  Формализация средств низкоуровневого программирования - дело непростое, и стандарт даже
  относительно несложного C занимает больше тысячи страниц. Стандарт же C++ - чудовищной сложности
  документ, и мало какой разработчик может его запомнить и, тем более, понять.

  Дело тут не в конкретном языковом комитете, а в том, что любой достаточно зрелый язык должен
  сохранять обратную совместимость с существующим кодом. Вместе с тем, сообщество С++ гордится тем,
  что их любимый язык не уступает в выразительности следующему поколению языков, тем же Rust или D.
  Уверен, будет еще не одно радикальное изменение стандарта...

  Мораль тут очевидна: любые средства построения абстракций имеют высокоуровневый характер и
  устаревают значительно быстрее интерфейсов, предоставляемых машиной. Разработчики языков могут
  попытаться предугадать спрос на те или иные средства, но первоначальный выбор часто оказывается
  неудачным, после чего язык снова приходится обновлять.

  В результате многие разработчики при разработке низкоуровневых библиотек в итоге могут выберут
  относительно простой и прозрачный C.

* Гадание на абстракциях

  Мы, программисты, живем абстракциями. Средства построения абстракции - механизмы, позволяющие нам
  строить все более сложные системы. Правильные механизмы абстрагирования от деталей реализации
  подсистем и, в конечном итоге, деталей самой машины определяют эволюцию языков программирования
  высокого уровня.

  Вместе с тем, необходимость иногда вести прямой диалог машиной - низкоуровневое программивание -
  никуда не делось. Отчасти так сложилось исторически, отчасти - по объективным причинам, но место,
  куда программисты приходят поговорить со своим богом - машиной - называется языком C.

  Программисты заметили, что в мире разработки языков сейчас происходит кембрийский взрыв новых
  (почти) низкоуровневых языков. Rust, Go, Nim, D, Zig и многие другие пытаются отобрать корону у C.
  Но уже одно это разнообразие означает, что должен быть какой-то lingua franca, единый способ
  создавать код, работающих на всех этих платформах. И здесь мы опять видим C с его почти уже
  болезненно примитивными и низкоуровневыми абстракциями.

  Пытаться угадать будущее - дело неблагодарное. Еще более неблагодарное занятие - гадание на
  абстракциях. Но я все же попробую.

  Последнее поколение языков низкоуровнего программирование пройдет путь C++: они наберут
  популярность в счет новых средств абстрагирования, обрастут стандартами и станут слишком сложными.
  Разработчики будут пытаться поддерживать актуальность своих языков, вкладывая в них дополнительные
  возможности построения абстракций. Но языки все равно устареют в тот момент, когда появится /еще
  одно/ поколение языков с еще более продвинутыми средствами спасения от сложности мира.

  А язык C, между тем, будет жить.
