* TODO Аннотация

  TODO: https://habr.com/ru/company/badoo/blog/420407/

* Содержание :TOC:
- [[#аннотация][Аннотация]]
- [[#парадокс-c][Парадокс C]]
- [[#язык-прошлого-из-прошлого][Язык прошлого из прошлого]]
- [[#ненаивная-критика-с][(Не?)наивная критика С]]
- [[#семейная-история-c][Семейная история: C++]]
- [[#гадание-на-абстракциях][Гадание на абстракциях]]

* Парадокс C

  За последние десятилетия академики и практики предложили множество интереснейших языков
  программирования: чистый и красивый Standard ML, практичный OCaml, радикальный Haskell, динамичный
  Smalltalk, несравненный в метапрограммировании D и многие другие. Какие-то из них ограниченно
  используются до сих пор, другие повлияли на следующие поколения языков, популярность третьих со
  временем просто тихо сошла на нет.

  Между тем, архаичный, противоречивый, примитивный, сделанный в самых худших традициях своего
  поколения языков C живее всех живых. Видимо, что-то Денис Ричи все-таки сделал правильно, что бы
  не говорили критики.

* Язык прошлого из прошлого

  Давайте вслух подумаем, что же есть такого в C, что сохраняет его актуальность до наших дней.

  Что бы кто ни говорил, но абстрактная машина Си чертовски похожа на реальную машину: работа с
  памятью через указатели и арифметика указателей, широкий набор типов, возможность при
  необходимости работать на уровне отдельных байтов. Это очень даже близко языкам ассемблера! Эти
  вещи - именно то, ради чего иногда все-таки приходится писать на С.

  Еще одна непреходящая причина популярности языка заключается именно в том, насколько легко открыть
  получившийся ассемблер и убедиться, насколько код на него похож.

  Си придает много значения вопросам обратной совместимости, и, как и машина, эволюционирует крайне
  медленно. Изрядная часть нововведений - желание устранить разницу между тем, как работает реальная
  машина, и тем, как это видит программист на C.

  Заметьте, что практически все высокоуровневые средства построения абстракций в C устарели. Из
  актуального, наверное, тут только бессмертные функции, структуры и текстовые макроподстановки.
  Если задуматься, то даже связанные с работой функций механизмы уже показывают свой возраст:
  половину "костылей" вокруг языка можно было бы удалить, будь у разработчиков возможность
  возвращать одновременно несколько значений из функций

  Откровенно музейные экспонаты: строки, завершаемые нулем; реализация широких символов; почти вся
  стандартная библиотека. Да что там..! Из стандартной библиотеки в наши дни использовать можно
  только простейшее побайтовое копирование. И хорошо еще, что консервативность языка не позволила
  включить в стандарт всякие мимолетные модные веяния, коих накопилось бы за 30 лет, прошедших с
  момента принятия стандарта ANSI.

  Главная мысль, на которую хочу обратить ваше внимание: продвинутые средства построения абстракций
  устаревают слишком быстро для использования в низкоуровневых языках, в отличие от долгоживущих
  инструментов для работы с низлежащей машиной.

* (Не?)наивная критика С

  В исходной статье, критикующей C, многократно подчеркивается, что C мало того, что не является
  низкоуровневым, так еще и не позволяет упрощать работу оптимизирующих компиляторов.

  Автор цитирует следующее определение низкоуровневого языка: "Язык программирования является
  низкоуровневым, если написанные на нём программы требуют внимания к несущественному". По мне так
  это слишком неоднозначное определение. В конце концов, иногда даже работа на уровне распределения
  регистров очень даже существенна! Например, при разработке тех же интерпретаторов языков
  по-настоящему высокого уровня вроде Lua.

  Раз уж мы говорим про "низкоуровневость" как близость к инструкциям реальной машины, то следует
  сказать что-то вроде "Язык программирования является настолько низкоуровневым, насколько он близок
  к языку ассемблера целевой платформы". В конце концов, языки ассемблера по определению - интерфейс
  процессора, и ниже уже только детали реализации конкретного набора инструкций в кремнии.

  В статье автор обижается, что в C слишком явно заложены черты, свойственные оригинальным машинам
  PDP-11: плоская лента памяти (aka единое адресное пространство) и последовательное выполнение
  программ.

  Но разве x86 и другие современные наборы инструкций не предоставляют именно эти абстракции?
  Плоская лента памяти в современные машины заложена так же, как существовала она в PDP-11.
  Современная виртуальная память, в сущности, это и есть та же самая лента памяти, с поправкой на
  изоляцию пользовательских процессов и огромный размер.

  Более того, ранние версии C вполне себе поддерживал прозу жизни программистов, работавших с
  ограниченными ресурсами. Например, сегментированной памяти и разными видами указателей.

  И кеши процессора - просто техника оптимизации этой самой ленты памяти. Не думаю, что замена C на
  любой другой языка отменит необходимость компенсировать разрыв в производительности между
  процессором и памятью.

  Еще один аргумент - слишком, эм, /последовательное/ выполнение программ - мне тоже не совсем
  понятен. Существование C - не аргумент при внедрении ILP (англ. instruction-level parallelism).

  Разработчики процессоров были бы счастливы беспечно повышать тактовую частоту, удлинять конвеер
  инструкций и не вносить в архитектуры сложные устройства вроде предсказателя ветвлений и механизмы
  внеочередного выполнения инструкций. Но физика скучна и строга, скорость памяти ограничена, а
  длинные конвееры процессоров надо чем-то заполнять. В производительных программах нам,
  программистам, пригодятся все доступные приемы - и ILP, и SIMD, и многоядерность - вне зависимости
  от используемого языка.

  Я больше скажу. Не так много языков, в которых есть возможность одновременно использовать и ILP, и
  SIMD, и многопоточность. Практически используемое надмножество стандарта C - один из них.

  Бессмысленно говорить про C как язык одной конкретной старой машины. Язык C и современные
  популярные архитектуры - это история /взаимного влияния/. Процессоры развивают поддержку популярных
  языков вроде C так же, как сами низкоуровневые языки эволюционируют под влиянием процессоров.

  Ну и напоследок замечу, что в самом широком смысле актуальные архитектуры имитируют машину
  Тьюринга. Ей же соответствует и абстрактная машина языка C. Но автор критикующей статьи Дэвид
  Чизнэлл - серьезный академик из Кембриджа, а в академической среде по ряду вполне достойных причин
  при разработке языков предпочитают отталкиваться от лямбда-исчисления. Доказано, что
  лямбда-исчисление эквивалентно машине Тьюринга по вычислительной мощности, но реализация его в
  железе не столь очевидна. С другой стороны, свойства языков, основанных на лямбда-исчислении,
  намного легче формализуются и именно поэтому академики их так любят.

* Семейная история: C++

  Консервативность C - притча во языцах. Но не все низкоуровневые языки выбрали столь консервативный
  подход к развитию.

  В семейство низкоуровневых языков принято включать С++, который в известной степени сохраняет
  низкоуровневые возможности C, но проводит гораздо более либеральную политику в вопросах
  включения в стандарт новых возможностей.

  Основа языка - все та же прямая работа с памятью, но поверх добавлено несколько поколений средств
  абстрагирования: классы, шаблоны классов и функций, богатая библиотека шаблонов и, наконец,
  современные средства метапрограммирования. Требование сохранения обратной совместимости означало,
  что новые возможности накладывались поверх старых, что получалось... Не совсем аккуратно.

  Формализация средств низкоуровневого программирования - дело непростое, и стандарт даже
  относительно несложного C занимает больше тысячи страниц. Стандарт же C++ - чудовищной сложности
  документ, и мало какой разработчик может его запомнить и, тем более, понять.

  Дело тут не в конкретном языковом комитете, а в том, что любой достаточно зрелый язык должен
  сохранять обратную совместимость с существующим кодом. Вместе с тем, сообщество С++ гордится тем,
  что их любимый язык не уступает в выразительности следующему поколению языков, тем же Rust или D.
  Уверен, будет еще не одно радикальное изменение стандарта...

  Мораль тут очевидна: любые средства построения абстракций имеют высокоуровневый характер и
  устаревают значительно быстрее интерфейсов, предоставляемых машиной. Разработчики языков могут
  попытаться предугадать спрос на те или иные средства, но первоначальный выбор часто оказывается
  неудачным, после чего язык снова приходится обновлять.

  В результате многие разработчики при разработке низкоуровневых библиотек в итоге могут выберут
  относительно простой C.

* Гадание на абстракциях

  Мы, программисты, живем абстракциями. Средства построения абстракции - механизмы, позволяющие нам
  строить все более сложные системы. Правильные механизмы абстрагирования от деталей реализации
  подсистем и, в конечном итоге, деталей самой машины определяют эволюцию языков программирования
  высокого уровня.

  Вместе с тем, необходимость иногда вести прямой диалог машиной - низкоуровневое программивание -
  никуда не делось. Отчасти так сложилось исторически, отчасти - по объективным причинам, но место,
  куда программисты приходят поговорить со своим богом - машиной - называется языком C.

  Программисты заметили, что в мире разработки языков сейчас происходит кембрийский взрыв новых
  (почти) низкоуровневых языков. Rust, Go, Nim, D, Zig и многие другие пытаются отобрать корону у C.
  Но уже одно это разнообразие означает, что должен быть какой-то lingua franca, единый способ
  создавать код, работающих на всех этих платформах. И здесь мы опять видим C с его почти уже
  болезненно примитивными и низкоуровневыми абстракциями.

  Пытаться угадать будущее - дело неблагодарное. Еще более неблагодарное занятие - гадание на
  абстракциях. Но я все же попробую.

  Последнее поколение языков низкоуровнего программирование пройдет путь C++: они наберут
  популярность в счет новых средств абстрагирования, обрастут стандартами и станут слишком сложными.
  Разработчики будут пытаться поддерживать актуальность своих языков, вкладывая в них дополнительные
  возможности построения абстракций. Но языки все равно устареют в тот момент, когда появится /еще
  одно/ поколение языков с еще более продвинутыми средствами спасения от сложности мира.

  А язык C, между тем, будет жить.
