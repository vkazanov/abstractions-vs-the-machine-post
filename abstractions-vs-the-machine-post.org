* И все же C - низкоуровневый язык

  За последние десятилетия академики и практики предложили множество интереснейших языков
  программирования: чистый и красивый Standard ML, практичный OCaml, бескомпромиссный Haskell,
  динамичный Smalltalk, несравненный в метапрограммировании D и многие другие. Какие-то из них
  ограниченно используются до сих пор, другие повлияли на следующие поколения языков, популярность
  третьих тихо сошла на нет. Между тем, архаичный, противоречивый, примитивный, сделанный в худших
  традициях своего поколения языков C (и его наследники) живее всех живых.

  Критика C - классический для нашей индустрии эпистолярный жанр. Она звучит то громче, то тише, но
  в последнее время буквально оглушает. Свежий пример - перевод статьи Дэвида Чизнэлла [[https://habr.com/ru/company/badoo/blog/420407/]["C - не
  низкоуровневый язык"]], опубликованный в нашем блоге. Про C можно разное сказать, в дизайне языка
  действительно много пренеприятнейший ошибок. Но "не низкоуровневый" - это уже слишком!

  Такую несправедливость было нельзя терпеть, и поэтому я собрался духом и перебрал аргументы
  исходной статьи...

* Содержание :TOC:
- [[#и-все-же-c---низкоуровневый-язык][И все же C - низкоуровневый язык]]
- [[#аргументы-дэвида-чизнэлла][Аргументы Дэвида Чизнэлла]]
- [[#pdp-11-как-машина-тьюринга][PDP-11 как машина Тьюринга]]
- [[#оптимизирующие-компиляторы][Оптимизирующие компиляторы]]
- [[#стандарт][Стандарт]]
- [[#альтернативные-архитектуры][Альтернативные архитектуры]]
- [[#язык-программирования-низкого-уровня][Язык программирования низкого уровня]]
- [[#критика-c][Критика C]]
- [[#секретный-ингредиент][Секретный ингредиент]]
- [[#дело-не-в-c][Дело не в C]]
- [[#семейная-история-c][Семейная история: C++]]
- [[#гадание-на-языках-программирования][Гадание на языках программирования]]

* Аргументы Дэвида Чизнэлла

  Если не обращать внимание на эмоциональную сторону статьи и упоминание ключевых слов (Meltdown и
  Spectre), то Чизнэлл приводит следующие аргументы:

  1. Абстрактная машина языка C слишком похожа на устаревшую архитектуру PDP-11.

  2. Язык C с трудом поддается автоматической оптимизации.

  3. Неполнота и сложность стандарта языка ведет к разночтениям в реализациях стандарта.

  4. Доминирование C-подобных языков не позволяет исследовать альтернативные архитектуры
     процессоров.

  Давайте поговорим о каждом из них по порядку, после чего вернемся к смыслу исходного термина "язык
  низкого уровня".

* PDP-11 как машина Тьюринга

  Давайте поговорим о PDP-11. В этой архитектуре программы выполняются последовательно, а память
  представляет собой плоскую ленту. На эту модель хорошо укладываются - и, соответственно,
  компилируются - любые императивные языки, в том числе C, Pascal и Fortran.

  Но дело не только в удобстве разработчиков компиляторов популярных языков. Плоская память и
  последовательные программы в популярных архитектурах соответствуют машине Тьюринга,
  фундаментальной модели из теории алгоритмов. Если не вдаваться в детали и определения, то можно
  просто сказать, что в рамках этой модели можно реализовать любой интересный алгоритм.

  Такая универсальность и тот факт, что машина Тьюринга очевидным образом имитируется в железе, и
  сделало эту модель базовой для большинства процессоров общего назначения.

  И вполне естественно, что со временем у разработчиков процессоров появилась необходимость
  оптимизировать исходную архитектуру.

  Разница в производительности памяти и центрального процессора привела к появлению кеширующих
  подсистем, одноуровневых и, позже, многоуровневых. От простого последовательного выполнения
  программ процессоры перешли к внеочередному выполнению (англ. instruction-level parallelism)
  инструкций в тех случаях, где инструкции не зависят друг от друга. В один процессор стали
  интегрировать несколько вычислительных ядер и появилась необходимость поддерживать когерентность
  кешей каждого из ядер...

  В конечном же итоге все это техники оптимизации архитектуры, имитирующую исходную модель - машину
  Тьюринга. И естественно, что абстрактная машина языка C (как и все императивные языки в целом)
  отталкивается именно от нее.

  Существует есть еще одна популярная модель вычислений: лямбда-исчисление. Доказано, что
  лямбда-исчисление эквивалентно машине Тьюринга по вычислительной мощности. Свойства языков
  программирования, основанных на лямбда-исчислении, намного легче формализуются и именно поэтому
  исследователи языков программирования их так любят. Кстати, называются такие языки функциональными.

  Дэвид Чизнэлл - академик и его критика абстрактной машины C это, в сущности, критика архитектур и
  языков программирования, моделирующих машину Тьюринга. И если присмотреться, то в его аргументах
  можно разглядеть знакомый нам всем спор между сторонниками функциональных языков программирования
  и языков императивных.

  И лично мне почему-то кажется, что в контексте языков программирования низкого уровня и популярных
  архитектур по очкам в настоящий момент определенно ведет команда Тьюринга.

* TODO Оптимизирующие компиляторы
* TODO Стандарт
* TODO Альтернативные архитектуры
* TODO Язык программирования низкого уровня

* Критика C
  В исходной статье, критикующей C, многократно подчеркивается, что C мало того, что не является
  низкоуровневым, так еще и не позволяет упрощать работу оптимизирующих компиляторов.

  Автор цитирует следующее определение низкоуровневого языка: "Язык программирования является
  низкоуровневым, если написанные на нём программы требуют внимания к несущественному". Я не стану
  здесь спорить, но замечу, что "несущественность" сильно зависит от конкретной задачи. При
  написании, например, базы данных или интерпретатора языка программирования несущественные в
  прикладном коде детали становятся очень даже существенными!

  Лично мне ближе следующее определение:"Язык программирования является настолько низкоуровневым,
  насколько он близок к языку ассемблера целевой платформы". В конце концов, языки ассемблера по
  определению - интерфейс процессора, и ниже уже только детали реализации конкретного набора
  инструкций в кремнии.

  И да, у абстрактной машины языка C много общего с нижележащей машиной: плоская лента памяти (aka
  единое адресное пространство), последовательное выполнение программ, изменяемые данные.
  Многоуровневые кеши процессора - просто техника оптимизации этой самой ленты памяти.

  Многоуровневый кеш, сложные протоколы когерентности кешей, ILP (instruction-level parallelism) со
  следущими из него переименованием регистров и предсказателем ветвлений - оптимизации этих самых
  плоской ленты памяти и последовательно выполняемых программ.

  Дело в том, что в самом широком смысле актуальные архитектуры имитируют не какой-то конкретный
  язык программирования, а машину Тьюринга. Ей же соответствует и абстрактная машина языка C.

  Но автор критикующей статьи Дэвид Чизнэлл - серьезный академик из Кембриджа, а в академической среде
  по ряду вполне достойных причин при разработке языков предпочитают отталкиваться от
  лямбда-исчисления.

  Доказано, что лямбда-исчисление эквивалентно машине Тьюринга по вычислительной мощности, но
  реализация его в железе не столь очевидна. С другой стороны, свойства языков, основанных на
  лямбда-исчислении, намного легче формализуются и именно поэтому академики их так любят.

  Но фокус именно в том, что физические машины - машины Тьюринга по сути. Эквивалентность
  эквивалентностью, но именно такая модель легче всего реализуется в транзисторах. Не PDP-11, не
  какой-то конкретный язык программирования, а десятилетия архитектурных экспериментов показали, что
  именно так достигается оптимальная производительность /в общем случае/.

  Подходы типа Lisp-машин или SIMD, лежащий в основе GPU и векторных АЛУ процессора, безусловного
  имеют смысл в специальных задачах, но ни в коем случае не универсальны. Itanium не даст соврать!

* Секретный ингредиент

  Надеюсь, мы выяснили, что абстрактная машина С похожа на машину реальную: возможность работать с
  памятью через указатели и арифметику указателей, близкий к железу набор типов, возможность при
  необходимости работать на уровне отдельных байтов. Полученные после прохода компилятора C листинги
  на языке ассемблера однозначно отображаются в исходный код. Все эти вещи - именно то, ради чего
  иногда все-таки приходится писать на С.

  Си придает много значения вопросам обратной совместимости, и, как и машина, эволюционирует крайне
  медленно. Изрядная часть нововведений - желание устранить разницу между тем, как работает реальная
  машина, и тем, как это видит программист на C.

  Заметьте, что практически все высокоуровневые средства построения абстракций в C устарели. Из
  актуального, наверное, тут только бессмертные функции, структуры и текстовые макроподстановки.
  Если задуматься, то даже связанные с работой функций механизмы уже показывают свой возраст:
  половину "костылей" языка можно было бы удалить, будь у разработчиков возможность возвращать
  одновременно несколько значений из функций.

  Откровенно музейные экспонаты: строки, завершаемые нулем; реализация широких символов; почти вся
  стандартная библиотека. Да что там..! Из стандартной библиотеки в наши дни использовать можно
  только простейшее побайтовое копирование. И хорошо еще, что консервативность языка не позволила
  включить в стандарт всякие мимолетные модные веяния, коих накопилось бы за 30 лет, прошедших с
  момента принятия стандарта ANSI.

  Словом, ключевая причина популярности C - не успех его как языка, а близость самой базовой модели,
  на которой строятся современные компьютеры.

* Дело не в C

  При ближайшем рассмотрении видно, что Дэвид Чизнэлл критикует не конкретный неудачный язык
  программирования, а императивную модель программирования вообще: ему не нравятся изменяемые
  данные, фиксированный порядок вычислений и следующие из них сложности параллельного
  программирования.

  Прямо Дэвид об этого не говорит, но из статьи следует, что единственная альтернатива современному
  положению дел - функциональное (и в меньшей степени логическое) программирование. Чего он не
  упоминает, так это то, что у функционального и логического программирования уже был свой звездный
  час где-то на изломе 80-х и 90-х, когда японцы серьезно вложились в "компьютеры пятого поколения",
  а американцы всерьез считал, что Лисп-машины позволят построить искусственный интеллект.

  Но внезапно выяснилось, что Prolog, Лиспы и иже с ними хороши в некоторых нишах, но неизбежно
  проигрывают в производительности скучным и универсальным императивным языкам и машинам: C и Pascal
  на x86 или Motorola.

  Чуть позже семейство языков ML показало, что рекурсивные алгоритмы на деревьях могут выглядеть
  красиво. Но, к примеру, код (эффективной) хэш-таблицы уже не столько изящен, без изменяемых-то
  данных... Словом, только *некоторые* алгоритмы действительно лучше излагаются на Haskell или Ocaml,
  но немалая часть Библии от Дональда Кнута труднореализуема на неизменяемых данных.

  Впрочем, в последние два десятилетия - с ростом популярности Интернета - область применимости
  функциональной парадигмы сильно расширилась: распределенные вычисления на десятках-сотнях машин
  действительно очень трудно на изменяемых данных.

  Но Hadoop, Spark и аналогичные инструменты лично у меня язык не повернется назвать
  "низкоуровневыми".

* Семейная история: C++

  Консервативность C - притча во языцах. Но не все низкоуровневые языки выбрали столь консервативный
  подход к развитию.

  В семейство низкоуровневых языков принято включать С++, который в известной степени сохраняет
  низкоуровневые возможности C, но проводит гораздо более либеральную политику при включении в
  стандарт новых возможностей.

  Основа языка - все та же прямая работа с памятью, но поверх добавлено несколько поколений средств
  абстрагирования: классы, шаблоны классов и функций, богатая библиотека шаблонов и, наконец,
  современные средства метапрограммирования. Требование сохранения обратной совместимости означало,
  что новые возможности накладывались поверх старых, что получалось... Не совсем аккуратно.

  Формализация средств низкоуровневого программирования - дело непростое, и стандарт даже
  относительно несложного C занимает больше тысячи страниц. Стандарт же C++ - чудовищной сложности
  документ, и мало какой разработчик может его запомнить и, тем более, понять.

  Дело тут не в конкретном языковом комитете, а в том, что любой достаточно зрелый язык должен
  сохранять обратную совместимость с существующим кодом. Изменения в стандарте языка - всегда
  расширение исходного и без того сложного документа.

  Вместе с тем, сообщество С++ гордится тем, что их любимый язык не уступает в выразительности
  следующему поколению языков, тем же Rust или D. Уверен, будет еще не одно радикальное изменение
  стандарта...

  Мораль тут очевидна: любые средства построения абстракций имеют высокоуровневый характер и
  устаревают значительно быстрее интерфейсов, предоставляемых машиной. Разработчики языков могут
  попытаться предугадать спрос на те или иные средства, но первоначальный выбор часто оказывается
  неудачным, после чего язык снова приходится обновлять.

  В результате многие разработчики при разработке низкоуровневых библиотек в итоге выбирают простой
  и близкий к машине C.

* Гадание на языках программирования

  Мы, программисты, живем абстракциями. Средства построения абстракции - механизмы, позволяющие нам
  строить все более сложные системы. Правильные механизмы абстрагирования от деталей реализации
  подсистем и, в конечном итоге, деталей самой машины определяют эволюцию языков программирования
  высокого уровня.

  И в этом смысле, конечно, C безнадежно устарел. Вместе с тем, необходимость иногда вести прямой
  диалог машиной - низкоуровневое программивание - никуда не делось. Отчасти так сложилось
  исторически, отчасти - по объективным причинам, но место, куда программисты приходят поговорить со
  своим богом - машиной - называется языком C.

  Программисты заметили, что после десятилетиях заигрывания с функциональной парадигмой в мире
  разработки языков внезапно произошел кембрийский взрыв новых (почти) низкоуровневых языков. Rust,
  Go, Nim, D, Zig и многие другие пытаются отобрать корону у C. Но уже одно это разнообразие
  означает, что должен быть какой-то lingua franca, единый способ создавать код, работающих на всех
  этих платформах. И, конечно, здесь мы опять видим C с его почти уже болезненно примитивными и
  низкоуровневыми абстракциями, но зато общим для всех интерфейсом.

  Последнее поколение языков низкоуровнего программирование пройдет путь C++: они наберут
  популярность в счет новых средств абстрагирования, обрастут стандартами и станут слишком сложными.
  Разработчики будут пытаться поддерживать актуальность своих языков, вкладывая в них дополнительные
  возможности построения абстракций. Но языки все равно устареют в тот момент, когда появится /еще
  одно/ поколение языков с еще более продвинутыми средствами спасения от сложности мира.

  А язык C, между тем, будет жить.
