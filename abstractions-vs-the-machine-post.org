* И все же C - низкоуровневый язык

  За прошедшие с момента появления языка C десятилетия академики и практики предложили множество
  интереснейших языков программирования. Какие-то из них ограниченно используются до сих пор, другие
  повлияли на следующие поколения языков, популярность третьих тихо сошла на нет. Между тем,
  архаичный, противоречивый, примитивный, сделанный в худших традициях своего поколения языков C (и
  его наследники) живее всех живых.

  Критика C - классический для нашей индустрии эпистолярный жанр. Она звучит то громче, то тише, но
  в последнее время буквально оглушает. Свежий пример - недавний перевод статьи Дэвида Чизнэлла [[https://habr.com/ru/company/badoo/blog/420407/]["C -
  не низкоуровневый язык"]], опубликованный в нашем блоге. Про C можно разное сказать, в дизайне языка
  действительно много пренеприятнейший ошибок. Но отказывать C в "низкоуровневости" - это уже
  слишком!

  Такую несправедливость нельзя было терпеть, и поэтому я собрался духом и перебрал аргументы
  исходной статьи...

* Содержание :TOC:
- [[#и-все-же-c---низкоуровневый-язык][И все же C - низкоуровневый язык]]
- [[#аргументы-дэвида-чизнэлла][Аргументы Дэвида Чизнэлла]]
- [[#дело-не-только-в-pdp-11][Дело не только в PDP-11]]
- [[#оптимизирующие-компиляторы-и-язык-низкого-уровня][Оптимизирующие компиляторы и язык низкого уровня]]
- [[#стандарт-как-безусловное-благо][Стандарт как безусловное благо]]
- [[#альтернативные-архитектуры---удел-специальных-вычислений][Альтернативные архитектуры - удел специальных вычислений]]
- [[#с-будет-жить][С будет жить]]

* Аргументы Дэвида Чизнэлла

  Если не обращать внимание на эмоциональную сторону статьи и упоминание ключевых слов (Meltdown и
  Spectre), то Чизнэлл приводит следующие аргументы:

  1. Абстрактная машина языка C слишком похожа на устаревшую архитектуру PDP-11.

  2. Автоматической оптимизация и C

  3. Неполнота и сложность стандарта языка ведет к разночтениям в реализациях стандарта.

  4. Доминирование C-подобных языков не позволяет исследовать альтернативные архитектуры
     процессоров.

  Давайте поговорим о каждом из них по порядку.

* Дело не только в PDP-11

  Давайте поговорим о PDP-11.

  В PDP-11 используется архитектура фон Неймана, в которой программы выполняются последовательно
  центральным процессором, а память представляет собой плоскую ленту, где хранятся и память и сами
  программы. Такая архитектура легко реализуется в железе и со временем компьютеры общего назначения
  стали использовать именно ее.

  Разница в производительности памяти и центрального процессора привела к появлению кеширующих
  подсистем, одноуровневых и, позже, многоуровневых. Со временем в один процессор стали
  интегрировать несколько вычислительных ядер и появилась необходимость поддерживать когерентность
  кешей каждого из ядер, для чего потребовались протоколы межядерного взаимодействия.

  Другая оптимизация - внеочередное выполнение (англ. instruction-level parallelism) инструкций -
  направлена на решение проблем иногда "простаивающего" при последовательном исполнении программ
  контроллера памяти,

  Эти и многие другие техники направлены на устранение узких мест в архитектуре фон Неймана.
  Абстрактная машина C - и многих других языков - имитирует работу не столько конкретно PDP-11,
  сколько устройство любых компьютеров, устроенных по этим принципам архитектуры фон Неймана.

  Чизнэлл критикует не абстрактную машину C, не конкретный язык, а засилье компьютеров, использующих
  архитектуру фон Неймана.

  Можно считать, что фоннеймановский подход устарел, можно считать, что он актуален, но это никак не
  отменяет того факта, что абстрактная машина C - воплощение этой самой архитектуры, причем
  воплощение подробное, то есть низкоуровневое.

* Оптимизирующие компиляторы и язык низкого уровня

  Еще один популярный аргумент критиков C сводится к тому, что в стандарте языка дается слишком
  много гарантий касательно, например, расположения отдельных полей в структурах и объединениях.
  Вместе с указателями и примитивными механизмами циклов это действительно усложняет работу
  оптимизатора.

  Чуть более декларативный подход позволил бы компилятору самостоятельно решать проблемы
  выравнивания данных в памяти или оптимального порядка полей в структурах; а высокоуровневые циклы
  дают свободу, необходимую при векторизации циклов.

  Позиция разработчиков C в данном случае: низкоуровневый язык должен позволять работать на уровне,
  достаточно низком для самостоятельного решения программистом задач оптимизации. В рамках C
  возможно самостоятельно поработать компилятором, выбрав, к примеру, инструкции SIMD и правильно
  разместить данные в памяти.

  Чизнэлл же в статье под названием "C - не низкоуровневый язык" утверждает, что C - *слишком*
  низкоуровневый.

  Отвлекаясь от именно статьи Чизнэлла хочу заметить, что в настоящий оптимизаторы выскокоуровневых
  языков, тех же C# или Java, вложено не меньше усилий, чем в GCC или LLVM. У функциональных языков
  тоже хватает эффективных оптимизирующих компиляторов: MLTon, OCaml и другие. Но те же разработчики
  OCaml пока могут похвастать производительностью в половину скорости кода на C...

* Стандарт как безусловное благо

  Полагаю, что кое-кто из читающих эту статью имел дело со стандартом C. У меня версия C99 есть в
  бумажном издании, страниц эдак на 900. Это не лаконичная спецификация Scheme меньше 100 страниц и
  не вылизанный Standard ML в 300. Удовольствие от работы с этим стандартом не получает никто: ни
  разработчики компиляторов, ни разработчики документа, ни программисты.

  Надо понимать, что стандарт C разрабатывался post factum, уже после появления множества
  почти-еле-только-местами-совместимых диалектов. Авторы ANSI C провели огромную работу, обобщив
  существующие реализации и прикрыв бесчисленными "костылями" неортогональности в дизайне языка. И
  даже странно, что такой документ вообще кто-то взялся реализовывать - и реализовал.

  Я не хочу пересказывать чужие байки о зоопарке мира Unix конца 80-х, тем более что сам в ту эпоху
  считал не дальше пяти. Но, очевидно, стандарт был всем в индустрии действительно нужен.

  Чудесно, что он есть, и он реализован. Прекрасно, что существует по меньшей мере 3 крупные
  конкурирующие реализацие и десятки компиляторов поменьше. Ни один из языков-конкурентов,
  претендующих на корону короля языков низкого уровня, не может похвастаться таким многообразием.
  Конкуренция - дело полезное, если верить биологом и экономистам.

  Мы, программисты, с этим стандартом живем и этим стандартом пользуемся. Да, местами он
  противоречивый и неоднозначный, да, все детали не может запомнить никто, но он существует и к нему
  возможно обратиться.

* Альтернативные архитектуры - удел специальных вычислений

  Последний аргумент, приводимый Чизнэллом, возвращается к устройству современных процессоров общего
  назначения, реализующих варианты архитектуры фон Неймана (PDP-11 и современные x86 и ARM-ы), с
  иерархией кешей над лентой памяти и последовательным выполнением программ.

  И, повторюсь, что эта критика касается не конкретно C, а самой базовой модели императивного
  программирования.

  Существует множество альтернатив традиционному подходу: модели в стиле GPU, абстрактная машина
  Erlang и другие. Но каждый из подходов имеет достаточно ограниченную применимость. GPU, например,
  замечательно перемножают матрицы в играх и машинном обучении, но их сложно использовать для
  трассировки лучей. Erlang прекрасно работает в кластере, но эффективный quick sort или быструю
  хэш-таблицу на нем сделать трудно.

  Между тем, современные x86-совместимые процессоры давно уже включают в себя наборы векторных
  инструкций, приближающих их к тем же GPU по устройству. Не сомневаюсь, что любые достаточно общие
  подходы к вычислениям немедленно будут будут включены в популярные ЦПУ.

  Есть авторитетное мнение, что будущее за специализированными периферийными устройствами - ASIC.
  Или еще более экономный вариант - FPGA. И под такие неординарные железки действительно имеет смысл
  разрабатывать отдельные языки с особой семантикой.

  Но компьютер общего назначения был и остается очень похожим на ту самую PDP-11, в паре с
  C-подобным языком императивным языком.

* С будет жить

  В статье Чизнэлла есть фундаментальное противоречие. Он пишет о том, что для обеспечения скорости
  программ на C процессоры имитируют абстрактную машину C (и давно забытую PDP-11), после чего
  жалуется на ограниченность этой самой машины. И тут же заявляет, что "C - не низкоуровневый язык".

  Дело в том, что Чизнэлл критикует не конкретный язык C, а популярные архитектуры и лежащую в их
  основе модель программирования. Честное название, следующее из статьи, должно звучать следующим
  образом: "Популярные архитектуры - ошибочное направление". Но это настолько сильное утверждение,
  что Чизнэлл напрямую его озвучить не решается, прячась за спорные утверждения о тлетворном влиянии
  PDP-11 и C на современные процессоры.

  В настоящий момент архитектура фон Неймана правит бал, и индустрии нужен язык, позволяющий в ее
  рамках работать на как можно более низком уровне. И достаточно простой, портированный на десятки
  платформ и стандартизированный язык программирования это C (и его ближайшие родственники).

  При всем при этом у C множество недостатков: архаичная стандартная библиотека, запутанный и
  противоречивый стандарт, грубые ошибки в дизайне языка. Но, судя по всему, кое-что создатели языка
  все же сделали правильно.

  Так может нам все-таки нужен язык низкого уровня? Пускай это не устаревший C, но хотя бы что-то
  похожее?
