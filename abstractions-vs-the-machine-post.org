* И все же C - низкоуровневый язык

  За последние десятилетия академики и практики предложили множество интереснейших языков
  программирования: чистый и красивый Standard ML, практичный OCaml, бескомпромиссный Haskell,
  динамичный Smalltalk, несравненный в метапрограммировании D и многие другие. Какие-то из них
  ограниченно используются до сих пор, другие повлияли на следующие поколения языков, популярность
  третьих тихо сошла на нет. Между тем, архаичный, противоречивый, примитивный, сделанный в худших
  традициях своего поколения языков C (и его наследники) живее всех живых.

  Критика C - классический для нашей индустрии эпистолярный жанр. Она звучит то громче, то тише, но
  в последнее время буквально оглушает. Свежий пример - перевод статьи Дэвида Чизнэлла [[https://habr.com/ru/company/badoo/blog/420407/]["C - не
  низкоуровневый язык"]], опубликованный в нашем блоге. Про C можно разное сказать, в дизайне языка
  действительно много пренеприятнейший ошибок. Но "не низкоуровневый" - это уже слишком!

  Такую несправедливость нельзя было терпеть, и поэтому я собрался духом и перебрал аргументы
  исходной статьи...

* Содержание :TOC:
- [[#и-все-же-c---низкоуровневый-язык][И все же C - низкоуровневый язык]]
- [[#аргументы-дэвида-чизнэлла][Аргументы Дэвида Чизнэлла]]
- [[#pdp-11-как-машина-тьюринга][PDP-11 как машина Тьюринга]]
- [[#оптимизирующие-компиляторы][Оптимизирующие компиляторы]]
- [[#стандарт][Стандарт]]
- [[#альтернативные-архитектуры][Альтернативные архитектуры]]
- [[#с-будет-жить][С будет жить]]

* Аргументы Дэвида Чизнэлла

  Если не обращать внимание на эмоциональную сторону статьи и упоминание ключевых слов (Meltdown и
  Spectre), то Чизнэлл приводит следующие аргументы:

  1. Абстрактная машина языка C слишком похожа на устаревшую архитектуру PDP-11.

  2. Язык C с трудом поддается автоматической оптимизации.

  3. Неполнота и сложность стандарта языка ведет к разночтениям в реализациях стандарта.

  4. Доминирование C-подобных языков не позволяет исследовать альтернативные архитектуры
     процессоров.

  Давайте поговорим о каждом из них по порядку, после чего вернемся к смыслу исходного термина "язык
  низкого уровня".

* PDP-11 как машина Тьюринга

  Давайте поговорим о PDP-11. В этой архитектуре программы выполняются последовательно, а память
  представляет собой плоскую ленту. На эту модель хорошо укладываются - и, соответственно,
  компилируются - любые императивные языки, в том числе C, Pascal и Fortran.

  Но дело не только в удобстве разработчиков компиляторов популярных языков. Плоская память и
  последовательные программы в популярных архитектурах соответствуют машине Тьюринга,
  фундаментальной модели из теории алгоритмов. Если не вдаваться в детали и определения, то можно
  просто сказать, что в рамках этой модели можно реализовать любой интересный алгоритм.

  Такая универсальность и тот факт, что машина Тьюринга очевидным образом имитируется в железе, и
  сделало эту модель базовой для процессоров общего назначения.

  И вполне естественно, что со временем у разработчиков процессоров появилась необходимость
  оптимизировать исходную архитектуру.

  Разница в производительности памяти и центрального процессора привела к появлению кеширующих
  подсистем, одноуровневых и, позже, многоуровневых. От простого последовательного выполнения
  программ процессоры перешли к внеочередному выполнению (англ. instruction-level parallelism)
  инструкций в тех случаях, где инструкции не зависят друг от друга. В один процессор стали
  интегрировать несколько вычислительных ядер и появилась необходимость поддерживать когерентность
  кешей каждого из ядер...

  В конечном же итоге все это техники оптимизации архитектуры, имитирующей исходную модель - машину
  Тьюринга. И естественно, что абстрактная машина языка C (как и все императивные языки в целом)
  отталкивается именно от нее.

  Существует есть еще одна популярная модель вычислений: лямбда-исчисление. Доказано, что
  лямбда-исчисление эквивалентно машине Тьюринга по вычислительной мощности. Свойства языков
  программирования, основанных на лямбда-исчислении, намного легче формализуются и именно поэтому
  исследователи языков программирования их так любят. Кстати, называются такие языки функциональными.

  Дэвид Чизнэлл - академик и его критика абстрактной машины C это, в сущности, критика архитектур и
  языков программирования, моделирующих машину Тьюринга. И если присмотреться, то в его аргументах
  можно разглядеть знакомый нам всем спор между сторонниками функциональных языков программирования
  и языков императивных.

  И лично мне почему-то кажется, что в контексте языков программирования низкого уровня и популярных
  архитектур по очкам в настоящий момент определенно ведет команда Тьюринга.

* Оптимизирующие компиляторы

  Еще один популярный аргумент критиков C сводится к тому, что в стандарте языка дается слишком
  много гарантий касательно, например, расположения отдельных полей в структурах и объединениях.
  Вместе с указателями и примитивными механизмами циклов это действительно усложняет работу
  оптимизатора.

  Утверждается, что только за счет огромных вложений в оптимизирующие компиляторы достигается такое
  превосходство в производительности C.

  Чуть более декларативный подход позволил бы компилятору решить вопросы выравнивания и смене
  порядка полей в структурах; а высокоуровневые циклы могли бы дать больше гарантий, необходимых при
  автоматической векторизации циклов.

  Я не могу не заметить, что среди языков, ведущих свою родословную от C, давно существует
  подходящий вариант - Java, где никакого доступа к байтам не существует и никаких лишних гарантий
  относительно физической структуры объектов программисту не дается. В оригинальный многоуровневый
  jit-компилятор из JVM вложено не меньше работы, чем в GCC или LLVM. При всем этом Java все равно
  медленней C.

  Со стороны же функциональных языков сильнейшим кандидатом на роль оптимизированного языка будет,
  пожалуй, OCaml. Ссылочная прозврачность, декларативность и все такое. Оптимизируй хоть до конца
  света! Разработчики Ocaml совершенно обоснованно хвастаются производительностью *в половину*
  скорости кода на C.

  При этом в рамках C я сам могу поработать компилятором, выбрав нужные мне инструкции SIMD и
  аккуратно разложив данные в памяти. И тогда никакая Java мой код не догонит в самых благоприятных
  синтетических тестах.

  Другими словами, современный программист-практик, которому нужна производительность, в типичном
  случае возьмет готовую быструю библиотеку на C, в редких же будет выбирать между C и его
  потомками.

  В конечном итоге промышленные языки программирования существуют не ради комфорта разработчиков
  компиляторов или отвлеченной теоретической стройности, а для написания прикладных программ на
  реально существующем железе. Отсюда следует простая мысль: не язык должен прогибаться под
  требования компилятора, а наоборот.

* Стандарт

  Полагаю, что кое-кто из читающих эту статью имел дело со стандартом C. У меня версия C99 есть в
  бумажном издании, страниц эдак на 900. Это не лаконичная спецификация Scheme на 100 страниц и не
  вылизанный Standard ML в 300. Удовольствие от работы с этим стандартом не получает никто: ни
  разработчики компиляторов, ни разработчики документа, ни программисты.

  Надо понимать, что стандарт C разрабатывался post factum, уже после появления множества
  почти-еле-только-местами-совместимых диалектов. Авторы ANSI C провели огромную работу, обобщив
  существующие реализации и прикрыв бесчисленными "костылями" неортогональности в дизайне языка. И
  даже странно, что такой документ вообще кто-то взялся реализовывать - и реализовал.

  Я не хочу пересказывать чужие байки о зоопарке мира Unix конца 80-х, тем более что сам в ту эпоху
  считал не дальше пяти. Но, очевидно, стандарт был всем в индустрии действительно нужен.

  Чудесно, что он есть, и он реализован. Прекрасно, что существует по меньшей мере 3 крупные
  конкурирующие реализацие и десятки компиляторов поменьше. Ни один из языков-конкурентов,
  претендующих на корону короля языков низкого уровня, не может похвастаться таким многообразием.
  Конкуренция - дело полезное, если верить биологом и экономистам.

  Мы, программисты, с этим стандартом живем и этим стандартом пользуемся. Да, местами он
  противоречивый и неоднозначный, да, все детали не может запомнить никто, но он существует и к нему
  возможно обратиться.

* Альтернативные архитектуры

  Последний аргумент, приводимый Чизнэллом, возвращается к устройству современных процессоров общего
  назначения, реализующих варианты машины Тьюринга (PDP-11 и современные x86 и ARM-ы), с иерархией
  кешей над лентой памяти и изменяемыми данными.

  И, повторюсь, что эта критика касается не конкретно C, а самой модели императивного
  программирования.

  Существует множество альтернатив традиционному подходу: модели в стиле GPU, абстрактная машина
  Erlang и другие. Но каждый из подходов имеет достаточно ограниченную применимость. GPU, например,
  замечательно перемножают матрицы в играх и машинном обучении, но их сложно использовать для
  трассировки лучей. Erlang прекрасно работает в кластере, но эффективный quick sort или быструю
  хэш-таблицу на нем сделать трудно.

  Между тем, современные x86-совместимые процессоры давно уже включают в себя наборы векторных
  инструкций, приближающих их к тем же GPU по устройству. Не сомневаюсь, что любые достаточно общие
  подходы к вычислениям немедленно будут будут включены в популярные ЦПУ.

  Есть авторитетное мнение, что будущее за специализированными периферийными устройствами - ASIC.
  Или еще более экономный вариант - FPGA. И под такие неординарные железки действительно имеет смысл
  разрабатывать отдельные языки с особой семантикой.

  Но процессор общего назначения был и остается очень похожим на ту самую PDP-11, в паре с
  C-подобным языком императивным языком.

* С будет жить

  В статье Чизнэлла есть интересное противоречие.

  Сначала он пишет о том, что для обеспечения скорости программ на C процессоры имитируют
  абстрактную машину C (и давно забытую PDP-11), после чего жалуется на ограниченность этой самой
  машины. И тут же заявляет, что "C - не низкоуровневый язык".

  Но критикует он не конкретный язык C, а именно архитектуры и лежащую в их основе модель
  программирования. Честное название, следующее из статьи, должно звучать как-то так: "Модель
  программирования, лежащая в основе популярнейших архитектур - ошибочное направление".

  Но это настолько сильное утверждение, что Чизнэлл напрямую его озвучить не решается, прячась за
  спорные утверждения о тлетворном влиянии PDP-11 и C на современные процессоры.

  Более того, его тезисы, касающиеся оптимизирующих компиляторов, выдают желаемое за действительное.
  На оптимизаторы альтернативных множества языков за последние десятилетия были потрачены тысячи
  человеко-лет, но синергия низкоуровневых возможностей C и универсальность Тьюринг-подобных машин
  по-прежнему сохраняет корону производительности за C.

  При всем при этом у C множество недостатков: архаичная стандартная библиотека, запутанный и
  противоречивый стандарт, грубые ошибки в дизайне языка. Но, судя по всему, что-то этот создатели
  язык сделали правильно, раз индустрия так и не смогла отказаться от его использования.

  Впрочем, в семействе C за последнее время случились прибавления: новые языки Rust, Zig, Nim и
  другие пытаются одновременно сохранить удачные аспекты C и исправить его недостатки. И в этом
  смысле C будет жить.
