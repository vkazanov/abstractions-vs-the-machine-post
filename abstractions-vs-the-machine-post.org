* TODO Аннотация

  https://habr.com/ru/company/badoo/blog/420407/

* DONE Standard ML - язык будущего из недавнего прошлого

  Несколько месяцев назад я перечитал замечательную книгу Эндрю Аппеля "Реализация компилятора в
  ML". Это одна из лучших книг о практической стороне разработки компиляторов и, несмотря на
  солидный возраст, она нисколько не потеряла в актуальности за те 20 лет, что прошли с момента
  первого издания. Если у вас есть хоть малейший интерес к теме - прочитайте обязательно. Если же вы
  уже понимаете компиляторы, то, полагаю, и без моих советов прекрасно знакомы с трудами Аппеля.

  У книги три версии - ML, C, Java - и общепризнанно лучшей считается именно версия на Standard ML.
  Я читал две из трех и не могу не заметить, что автор откровенно недолюбливает Java и C, и
  поленился даже ознакомиться с ключевыми идиомами языков.

  Почему же именно ML? В наши дни это прозвучит странно, но в свое время казалось, что за Standard
  ML - большое будущее. Язык вобрал в себя все лучшее, что было накоплено за десятилетия
  исследований в области теории языков программирования: полностью автоматический вывод всех типов,
  безболезненный полиформфизм, роскошное сопоставление с образцами (англ. pattern matching), мощная
  система модулей, в концу концов, комфортный синтаксис.

  Язык не пошел по пути неинтуитивных ленивых вычислений, были добавлены практичные возможности
  вроде ссылок на изменяемые (англ. mutable) значения, к базовому стандарту языку прилагалось
  расширение - описание стандартной библиотеки.

  В конце концов, Standard ML - строчный и логичный язык. Чтобы войти в курс дела достаточно
  прочитать и проработать буквально пару сотен страниц. Сравните с Haskell, который всем хорош, но
  немного напоминает мой любимый Emacs в том смысле, что процесс (пере-)освоения не заканчивается
  никогда.

  Наличие стандартов означало, что вместо обычной в наши дни референсной реализации языка появилось
  несколько конкурирующих компиляторов. Компиляторов Standard ML несколько, и по крайней мере два из
  них - настоящие произведения искусства, к идеям которых обращались и обращаются до сих пор
  разработчики компиляторов более популярных языков программирования.

  Словом, в Standard ML замечательно все, кроме незначительной детали - никому нет до него дела. Я
  понимаю, что академиков такие пошлости не смущают, но все же интересно понять, что же могло пойти
  не так.

  Между тем, архаичный, противоречивый, примитивный, сделанный в самых наколенных традициях C живее
  всех живых. Как же так..?

* DONE C  - актуальный язык прошлого из прошлого

  Давайте подумаем, что же есть такого в C, что сохраняет его актуальность до наших дней.

  Что бы кто ни говорил, но абстрактная машина Си чертовски похожа на реальную машину: работа с
  памятью через указатели и арифметика указателей, широкий набор типов, возможность при
  необходимости работать на уровне отдельных байтов. Это очень даже близко языкам ассемблера! Эти
  вещи - именно то, ради чего иногда все-таки приходится писать на С.

  Непреходящая причина популярности языка заключается именно в том, насколько легко открыть
  получившийся ассемблер и убедиться, насколько код на него похож.

  Си придает много значения вопросам обратной совместимости, и, как и машина, эволюционирует крайне
  медленно - как и машина. Изрядная часть расширений - желание устранить разницу между тем, как
  работает реальная машина, и тем, как это видит программист на C.

  Заметьте, что практически все высокоуровневые средства построения абстракций в C устарели. Из
  актуального, наверное, тут только бессмертные функции и структуры плюс текстовые макроподстановки.
  Если задуматься, то даже связанные с работой функций механизмы уже показывают свой возраст:
  половину "костылей" вокруг языка можно было бы удалить, будь у разработчиков возможность
  возвращать несколько значений из функций

  Откровенно музейные экспонаты: строки, завершаемые нулем; реализация широких символов; почти вся
  стандартная библиотека. Да что там..! Из стандартной библиотеки в наши дни использовать можно
  только простейшее побайтовое копирование. И хорошо еще, что консервативность языка не позволила
  включить в стандарт всякие мимолетные модные веяния.

  Главная мысль, на которую хочу обратить ваше внимание: продвинутые средства построения абстракций
  устаревают слишком быстро для использования в низкоуровневых языках, в отличие от долгоживущих
  инструментов для работы с низлежащей машиной.

* DONE (Не-)наивная критика С

  В исходной статье, критикующей C, многократно подчеркивается, что этот язык мало того, что не
  является низкоуровневым, так еще и не позволяет упрощать работу оптимизирующих компиляторов.

  Автор цитирует следующее определение низкоуровневого языка: "Язык программирования является
  низкоуровневым, если написанные на нём программы требуют внимания к несущественному". По мне так
  это слишком неоднозначное определение. В конце концов, иногда работа на уровне распределения
  регистров очень даже существенна! Например, при разработке тех же интерпретаторов языков
  по-настоящему высокого уровня.

  Раз уж мы говорим про "низкоуровневость" как близость к инструкциям реальной машины, то следует
  сказать что-то вроде "Язык программирования является настолько низкоуровневым, насколько он близок
  к языку ассемблера целевой платформы". В конце концов, языки ассемблера по определению - интерфейс
  процессора, и ниже только микрокод.

  В статье автор обижается, что в C слишком явно заложены черты, свойственные оригинальным машинам
  PDP-11: плоская лента памяти (aka единое адресное пространство) и последовательное выполнение
  программ.

  Но разве x86 и другие современные наборы инструкций не предоставляют именно эти абстракции?
  Плоская лента памяти в современные машины заложена так же, как существовала она в PDP-11.
  Современная виртуальная память, в сущности, это и есть та же самая лента памяти, с поправкой на
  изоляцию пользовательских процессов и огромный размер.

  Более того, ранние версии C вполне себе поддерживал прозу жизни программистов, работавших с
  ограниченными ресурсами. Например, сегментированной памяти и разными видами указателей.

  И кеши - просто техника оптимизации этой самой ленты. Не думаю, что замена C на любой другой языка
  отменит необходимость компенсировать разрыв в производительности между процессором и памятью.

  Еще один аргумент - слишком, эм, /последовательное/ выполнение программ - мне тоже не совсем
  понятен. Существование C - не аргумент при внедрении ILP (англ. instruction-level parallelism).

  Разработчики процессоров были бы счастливы беспечно повышать тактовую частоту, удлинять конвеер
  инструкций и не вносить в архитектуры сложные устройства вроде предсказателя ветвлений и механизмы
  внеочередного выполнения инструкций. Но физика скучна и строга, скорость памяти ограничена, а
  длинные конвееры процессоров надо чем-то заполнять. И в производительных программах нам,
  программистам, пригодятся все доступные приемы - и ILP, и SIMD и множество ядер - вне зависимости
  от используемого языка.

  Я больше скажу. Не так много языков, в которых есть возможность одновременно использовать и ILP, и
  SIMD, и многопоточность. Практически используемый C, кстати, один из них.

  Глупо и бессмысленно говорить про C как язык одной конкретной старой машины. Язык C и современные
  популярные архитектуры - это история /взаимного влияния/. Процессоры развивают поддержку популярных
  языков вроде C так же, как сами низкоуровневые языки эволюционируют под влиянием процессоров.

  Ну и напоследок замечу, что в самом широком смысле актуальные распространенные архитектуры
  имитируют машину Тьюринга. Ей же соответствует и абстрактная машина языка C. Но Дэвид Чизнэлл -
  серьезный академик из Кембриджа, а в академической среде по ряду вполне достойных причин
  предпочитают отталкиваться от лямбда-исчисления. Последнее, конечно же, эквивалентно машине
  Тьюринга, но реализация его в железе не столь очевидна.

* DONE Семейная история: C++

  В семейство низкоуровневых языков принято включать С++, который в известной степени сохраняет
  низкоуровневые возможности C, но проводит гораздо более либеральную политику в вопросах
  включения в стандарт новых возможностей.

  Основа языка - все та же прямая работа с памятью, но поверх добавлено несколько поколений средств
  абстрагирования: классы, шаблоны классов и функций, богатая библиотека шаблонов и, наконец,
  современные средства для метапрограммирования. Требование сохранения обратной совместимости
  означало, что новые возможности накладывались поверх старых, что не всегда получалось...
  Аккуратно.

  Формализация даже базовых низкоуровневых средств - дело непростое, и стандарт относительно
  несложного C занимает больше тысячи страниц. Стандарт же C++ - чудовищной сложности документ, и
  мало какой разработчик может его запомнить и, тем более, понять.

  Дело тут не в конкретном языковом комитете, а в том, что любой достаточно зрелый язык должен
  сохранять обратную совместимость с существующим кодом. Вместе с тем, сообщество С++ гордится тем,
  что их любимый язык не уступает в выразительности следующему поколению языков, тем же Rust или D.
  Будет еще не одно расширение стандарта...

  Мораль тут очевидная: любые средства построения абстракций имеют высокоуровневый характер и
  устаревают значительно быстрее интерфейсов, предоставляемых машиной. Разработчики языков могут
  попытаться предугадать спрос на те или иные средства, но рано или поздно язык все равно придется
  обновлять или менять, и первоначальный выбор может оказаться неправильным.

* DONE И снова о Standard ML

  Так что же случилось со Standard ML? Как коллекция интересных идей этот язык выполнил свою роль,
  оказав серьезное влияние на следующее поколение околоакадемических языков. Ближайший его
  родственник с чуть более прагматичным мировоззрением - OCaml - относительно широко используется как
  в академической среде, так и в индустрии. На связанные с компиляторами SML публикации ссылаются
  сотни производных работ.

  Некоторые из базовых идей языка, конечно же, по-прежнему актуальны, скажем, волшебное
  сопоставление с образцом или система модулей. Но с практической стороны язык, безусловно, устарел:
  стандартная библиотека по современным меркам слишком ограничена, вообще нет средств управления
  пакетами, толком не получится работать с Unicode-строками.

  Кирпичики, из которых строился язык, начинают осыпаться. Абстракции устарели, а долгоживущих
  ценностей, близких машине, в SML никогда и не было.

* TODO Вместо выводов: гадание на абстракциях

  - конкретные высокоуровневые средства построения абстракций быстро устаревают

  - элементы языка, соответствующие долгоживущим аспектам машины, живут долго

  - метапрограммирование как зло

  - метапрограммирование как элексир вечной жизни

  - многочисленность альтернатив означает, что Си как формализованный интерфейс между машиной и
    языками программирования будет жить

  - (emacs-)lisp будет жить!

  - ziglang?

  - rust?

  - go?
