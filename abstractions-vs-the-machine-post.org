* TODO Аннотация

  https://habr.com/ru/company/badoo/blog/420407/

* DONE Standard ML - язык будущего из недавнего прошлого

  Несколько месяцев назад я перечитал замечательную книгу Эндрю Аппеля "Реализация компилятора в
  ML". Это одна из лучших книг о практической стороне разработки компиляторов и, несмотря на
  солидный возраст, она нисколько не потеряла в актуальности за те 20 лет, что прошли с момента
  первого издания. Если у вас есть хоть малейший интерес к теме - прочитайте обязательно. Если же вы
  уже понимаете компиляторы, то, полагаю, и без моих советов прекрасно знакомы с трудами Аппеля.

  У книги три версии - ML, C, Java - и общепризнанно лучшей считается именно версия на Standard ML.
  Я читал две из трех и не могу не заметить, что автор откровенно недолюбливает Java и C, и
  поленился даже ознакомиться с ключевыми идиомами языков.

  Почему же именно SML? В наши дни это прозвучит странно, но в свое время казалось, что за Standard
  ML - большое будущее. Язык вобрал в себя все лучшее, что было накоплено за десятилетия
  исследований в области теории языков программирования: полностью автоматический вывод всех типов,
  безболезненный полиформфизм, роскошное сопоставление с образцами (англ. pattern matching), мощная
  система модулей, в концу концов, комфортный синтаксис.

  Язык не пошел по пути неинтуитивных ленивых вычислений, были добавлены практичные возможности
  вроде ссылок на изменяемые (англ. mutable) значения, к базовому стандарту языку прилагалось
  расширение - описание стандартной библиотеки.

  В конце концов, Standard ML - стройный и логичный язык. Чтобы войти в курс дела достаточно
  прочитать и проработать буквально пару сотен страниц. Сравните с Haskell, который всем хорош, но
  немного напоминает мой любимый Emacs в том смысле, что процесс (пере-)освоения не заканчивается
  никогда.

  Наличие стандартов означало, что вместо обычной в наши дни референсной реализации языка появилось
  несколько конкурирующих компиляторов. По крайней мере два компилятора Standard ML смело можно
  назвать произведениями искусства, к идеям которых обращались и обращаются до сих пор разработчики
  компиляторов более популярных языков программирования.

  Словом, в Standard ML замечательно все, кроме незначительной детали - никому нет до него дела. Я
  понимаю, что академиков такие пошлости не смущают, но все же интересно было бы понять, что могло
  пойти не так.

  Между тем, архаичный, противоречивый, примитивный, сделанный в самых наколенных традициях C живее
  всех живых. Как же так..?

* DONE C  - язык прошлого из прошлого

  Для начала давайте вслух подумаем, что же есть такого в C, что сохраняет его актуальность до наших
  дней.

  Что бы кто ни говорил, но абстрактная машина Си чертовски похожа на реальную машину: работа с
  памятью через указатели и арифметика указателей, широкий набор типов, возможность при
  необходимости работать на уровне отдельных байтов. Это очень даже близко языкам ассемблера! Эти
  вещи - именно то, ради чего иногда все-таки приходится писать на С.

  Еще одна непреходящая причина популярности языка заключается именно в том, насколько легко открыть
  получившийся ассемблер и убедиться, насколько код на него похож.

  Си придает много значения вопросам обратной совместимости, и, как и машина, эволюционирует крайне
  медленно. Изрядная часть расширений - желание устранить разницу между тем, как работает реальная
  машина, и тем, как это видит программист на C.

  Заметьте, что практически все высокоуровневые средства построения абстракций в C устарели. Из
  актуального, наверное, тут только бессмертные функции и структуры плюс текстовые макроподстановки.
  Если задуматься, то даже связанные с работой функций механизмы уже показывают свой возраст:
  половину "костылей" вокруг языка можно было бы удалить, будь у разработчиков возможность
  возвращать одновременно несколько значений из функций

  Откровенно музейные экспонаты: строки, завершаемые нулем; реализация широких символов; почти вся
  стандартная библиотека. Да что там..! Из стандартной библиотеки в наши дни использовать можно
  только простейшее побайтовое копирование. И хорошо еще, что консервативность языка не позволила
  включить в стандарт всякие мимолетные модные веяния.

  Главная мысль, на которую хочу обратить ваше внимание: продвинутые средства построения абстракций
  устаревают слишком быстро для использования в низкоуровневых языках, в отличие от долгоживущих
  инструментов для работы с низлежащей машиной.

* DONE (Не?)наивная критика С

  В исходной статье, критикующей C, многократно подчеркивается, что этот язык мало того, что не
  является низкоуровневым, так еще и не позволяет упрощать работу оптимизирующих компиляторов.

  Автор цитирует следующее определение низкоуровневого языка: "Язык программирования является
  низкоуровневым, если написанные на нём программы требуют внимания к несущественному". По мне так
  это слишком неоднозначное определение. В конце концов, иногда даже работа на уровне распределения
  регистров очень даже существенна! Например, при разработке тех же интерпретаторов языков
  по-настоящему высокого уровня вроде Lua.

  Раз уж мы говорим про "низкоуровневость" как близость к инструкциям реальной машины, то следует
  сказать что-то вроде "Язык программирования является настолько низкоуровневым, насколько он близок
  к языку ассемблера целевой платформы". В конце концов, языки ассемблера по определению - интерфейс
  процессора, и ниже уже только детали реализации конкретного набора инструкций в кремнии.

  В статье автор обижается, что в C слишком явно заложены черты, свойственные оригинальным машинам
  PDP-11: плоская лента памяти (aka единое адресное пространство) и последовательное выполнение
  программ.

  Но разве x86 и другие современные наборы инструкций не предоставляют именно эти абстракции?
  Плоская лента памяти в современные машины заложена так же, как существовала она в PDP-11.
  Современная виртуальная память, в сущности, это и есть та же самая лента памяти, с поправкой на
  изоляцию пользовательских процессов и огромный размер.

  Более того, ранние версии C вполне себе поддерживал прозу жизни программистов, работавших с
  ограниченными ресурсами. Например, сегментированной памяти и разными видами указателей.

  И кеши - просто техника оптимизации этой самой ленты. Не думаю, что замена C на любой другой языка
  отменит необходимость компенсировать разрыв в производительности между процессором и памятью.

  Еще один аргумент - слишком, эм, /последовательное/ выполнение программ - мне тоже не совсем
  понятен. Существование C - не аргумент при внедрении ILP (англ. instruction-level parallelism).

  Разработчики процессоров были бы счастливы беспечно повышать тактовую частоту, удлинять конвеер
  инструкций и не вносить в архитектуры сложные устройства вроде предсказателя ветвлений и механизмы
  внеочередного выполнения инструкций. Но физика скучна и строга, скорость памяти ограничена, а
  длинные конвееры процессоров надо чем-то заполнять. И в производительных программах нам,
  программистам, пригодятся все доступные приемы - и ILP, и SIMD, и многоядерность - вне зависимости
  от используемого языка.

  Я больше скажу. Не так много языков, в которых есть возможность одновременно использовать и ILP, и
  SIMD, и многопоточность. Практически используемый C, кстати, один из них.

  Бессмысленно говорить про C как язык одной конкретной старой машины. Язык C и современные
  популярные архитектуры - это история /взаимного влияния/. Процессоры развивают поддержку популярных
  языков вроде C так же, как сами низкоуровневые языки эволюционируют под влиянием процессоров.

  Ну и напоследок замечу, что в самом широком смысле актуальные архитектуры имитируют машину
  Тьюринга. Ей же соответствует и абстрактная машина языка C. Но Дэвид Чизнэлл - серьезный академик
  из Кембриджа, а в академической среде по ряду вполне достойных причин предпочитают отталкиваться
  от лямбда-исчисления. Последнее, конечно же, эквивалентно машине Тьюринга, но реализация его в
  железе не столь очевидна.

* DONE Семейная история: C++

  Консервативность C - притча во языцах. Но не все низкоуровневые языки выбрали столь консервативный
  подход к развитию.

  В семейство низкоуровневых языков принято включать С++, который в известной степени сохраняет
  низкоуровневые возможности C, но проводит гораздо более либеральную политику в вопросах
  включения в стандарт новых возможностей.

  Основа языка - все та же прямая работа с памятью, но поверх добавлено несколько поколений средств
  абстрагирования: классы, шаблоны классов и функций, богатая библиотека шаблонов и, наконец,
  современные средства для метапрограммирования. Требование сохранения обратной совместимости
  означало, что новые возможности накладывались поверх старых, что не всегда получалось...
  Аккуратно.

  Формализация даже базовых низкоуровневых средств - дело непростое, и стандарт относительно
  несложного C занимает больше тысячи страниц. Стандарт же C++ - чудовищной сложности документ, и
  мало какой разработчик может его запомнить и, тем более, понять.

  Дело тут не в конкретном языковом комитете, а в том, что любой достаточно зрелый язык должен
  сохранять обратную совместимость с существующим кодом. Вместе с тем, сообщество С++ гордится тем,
  что их любимый язык не уступает в выразительности следующему поколению языков, тем же Rust или D.
  Уверен, будет еще не одно расширение стандарта...

  Мораль тут очевидна: любые средства построения абстракций имеют высокоуровневый характер и
  устаревают значительно быстрее интерфейсов, предоставляемых машиной. Разработчики языков могут
  попытаться предугадать спрос на те или иные средства, но рано или поздно язык все равно придется
  обновлять или менять, и первоначальный выбор может оказаться неправильным.

* DONE И снова о Standard ML

  Так что же случилось со Standard ML? Как коллекция интересных идей этот язык выполнил свою роль,
  оказав серьезное влияние на следующее поколение околоакадемических языков. Ближайший его
  родственник с чуть более прагматичным мировоззрением - OCaml - относительно широко используется как
  в академической среде, так и в индустрии. На связанные с компиляторами SML публикации ссылаются
  сотни производных работ.

  Некоторые из базовых идей языка, конечно же, по-прежнему актуальны, скажем, волшебное
  сопоставление с образцом или система модулей. Но с практической стороны язык, безусловно, устарел:
  стандартная библиотека по современным меркам слишком ограничена, вообще нет средств управления
  пакетами, толком не получится работать с Unicode-строками.

  Кирпичики, из которых строился язык, начинают осыпаться. Абстракции устарели, а долгоиграющих
  ценностей, близких машине, в SML никогда и не было.

* DONE Гадание на абстракциях

  Мы, программисты, живем абстракциями. Средства построения абстракции - механизмы, позволяющие нам
  строить все более сложные системы. Правильные механизмы абстрагирования от деталей реализации
  подсистем и, в конечном итоге, деталей самой машины определяют эволюцию языков программирования
  высокого уровня.

  Вместе с тем, необходимость иногда вести прямой диалог машиной - низкоуровневое программивание -
  никуда не делось. Отчасти так сложилось исторически, отчасти - по объективным причинам, но место,
  куда программисты приходят поговорить со своим богом - машиной - называется языком C.

  Программисты заметили, что в мире разработки языков сейчас происходит кембрийский взрыв новых
  (почти) низкоуровневых языков. Rust, Go, Nim, D, Zig и многие другие пытаются отобрать корону у C.
  Но уже одно это разнообразие означает, что должен быть какой-то lingua franca, единый способ
  создавать код, работающих на всех этих платформах. И здесь мы опять видим C с его почти уже
  болезненно примитивными и низкоуровневыми абстракциями.

  Пытаться угадать будущее - дело неблагодарное. Еще более неблагодарное занятие - гадание на
  абстракциях. Но я все же попробую.

  Последнее поколение языков низкоуровнего программирование пройдет путь C++: они наберут
  популярность в счет новых средств абстрагирования, обрастут стандартами и станут слишком сложными.
  Будут пытаться поддерживать актуальность, внося - не слишком аккуратно - дополнительные
  возможности. И устареют в тот момент, когда появится /еще одно/ поколение языков с еще более
  продвинутыми средствами спасения от сложности мира.

  А язык C, между тем, будет жить.
